<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Nine Men's Morris</title>
<style>
:root{
  --board-bg:#d1d5db;
  --board-edge:#4b5563;
  --line:#4b5563;
  --white-piece:#fef3c7;
  --white-border:#b45309;
  --black-piece:#020617;
  --black-border:#e5e7eb;
  --highlight:#3b82f6;
}
*{box-sizing:border-box;}

body{
  margin:0;
  padding:40px 16px;
  background:#f3f4f6;
  font-family:ui-sans-serif,system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",Segoe UI,Roboto,Helvetica,Arial;
  text-align:center;
}

button{
  padding:10px 16px;
  margin:6px;
  font-size:15px;
  cursor:pointer;
  border-radius:8px;
  border:1px solid #4b5563;
  background:#fff;
  transition:0.15s;
}
button:hover{
  transform:translateY(-1px);
  background:#f9fafb;
  box-shadow:0 4px 10px rgba(0,0,0,0.12);
}

.hidden{display:none;}

#game-screen,#start-screen{
  max-width:640px;
  margin:0 auto;
}

#board-wrapper{display:flex;justify-content:center;}

#board{
  width:400px;
  max-width:90vw;
  aspect-ratio:1/1;
  position:relative;
  border-radius:24px;
  background:radial-gradient(circle at 20% -10%,#e5e7eb,var(--board-bg));
  border:3px solid var(--board-edge);
  box-shadow:0 12px 40px rgba(0,0,0,0.22);
}

.square{
  position:absolute;
  border:2px solid var(--line);
  pointer-events:none;
}
.square.outer{top:10%;left:10%;right:10%;bottom:10%;}
.square.middle{top:20%;left:20%;right:20%;bottom:20%;}
.square.inner{top:30%;left:30%;right:30%;bottom:30%;}

.cell{
  width:24px;height:24px;border-radius:50%;
  position:absolute;transform:translate(-50%,-50%);
  cursor:pointer;z-index:1;
}
.cell.empty{background:#e5e7eb;border:2px solid var(--board-edge);}
.cell.W{
  background:var(--white-piece);border:3px solid var(--white-border);
  box-shadow:0 0 0 2px rgba(255,255,255,0.7);
}
.cell.B{
  background:var(--black-piece);border:3px solid var(--black-border);
  box-shadow:0 0 0 2px rgba(0,0,0,0.5);
}
.cell.selected{box-shadow:0 0 0 4px rgba(59,130,246,0.9);}

#result-overlay{
  position:fixed;inset:0;
  background:rgba(15,23,42,0.55);
  display:flex;align-items:center;justify-content:center;
  z-index:1000;
}
#result-overlay.hidden{display:none;}
#result-box{
  background:#111827;color:#f9fafb;
  padding:20px;border-radius:16px;
  border:1px solid #4b5563;
  min-width:260px;
}
</style>
</head>

<body>

<!-- 시작 화면 -->
<div id="start-screen">
  <h1>Nine Men's Morris</h1>
  <p>혼자 게임하기: 플레이어 vs 컴퓨터 (선/후공 랜덤)</p>
  <p>둘이 게임하기: 같은 컴퓨터에서 번갈아 두기</p>
  <button id="btn-single">혼자 게임하기</button>
  <button id="btn-multi">둘이 게임하기</button>
</div>

<!-- 게임 화면 -->
<div id="game-screen" class="hidden">
  <div id="mode-text"></div>
  <div id="turn-text"></div>
  <div id="role-text" style="font-size:13px;color:#4b5563;margin-bottom:8px;"></div>

  <div id="board-wrapper">
    <div id="board">

      <div class="square outer"></div>
      <div class="square middle"></div>
      <div class="square inner"></div>

      <!-- 바깥 8 -->
      <div class="cell empty" data-index="0"  style="left:10%; top:10%;"></div>
      <div class="cell empty" data-index="1"  style="left:50%; top:10%;"></div>
      <div class="cell empty" data-index="2"  style="left:90%; top:10%;"></div>
      <div class="cell empty" data-index="9"  style="left:10%; top:50%;"></div>
      <div class="cell empty" data-index="14" style="left:90%; top:50%;"></div>
      <div class="cell empty" data-index="21" style="left:10%; top:90%;"></div>
      <div class="cell empty" data-index="22" style="left:50%; top:90%;"></div>
      <div class="cell empty" data-index="23" style="left:90%; top:90%;"></div>

      <!-- 중간 8 -->
      <div class="cell empty" data-index="3"  style="left:20%; top:20%;"></div>
      <div class="cell empty" data-index="4"  style="left:50%; top:20%;"></div>
      <div class="cell empty" data-index="5"  style="left:80%; top:20%;"></div>
      <div class="cell empty" data-index="10" style="left:20%; top:50%;"></div>
      <div class="cell empty" data-index="13" style="left:80%; top:50%;"></div>
      <div class="cell empty" data-index="18" style="left:20%; top:80%;"></div>
      <div class="cell empty" data-index="19" style="left:50%; top:80%;"></div>
      <div class="cell empty" data-index="20" style="left:80%; top:80%;"></div>

      <!-- 안쪽 8 -->
      <div class="cell empty" data-index="6"  style="left:30%; top:30%;"></div>
      <div class="cell empty" data-index="7"  style="left:50%; top:30%;"></div>
      <div class="cell empty" data-index="8"  style="left:70%; top:30%;"></div>
      <div class="cell empty" data-index="11" style="left:30%; top:50%;"></div>
      <div class="cell empty" data-index="12" style="left:70%; top:50%;"></div>
      <div class="cell empty" data-index="15" style="left:30%; top:70%;"></div>
      <div class="cell empty" data-index="16" style="left:50%; top:70%;"></div>
      <div class="cell empty" data-index="17" style="left:70%; top:70%;"></div>

    </div>
  </div>

  <div id="hint-text"></div>

  <button id="btn-back">처음으로</button>
</div>

<!-- 결과화면 -->
<div id="result-overlay" class="hidden">
  <div id="result-box">
    <div id="result-message" style="font-size:22px;margin-bottom:8px;"></div>
    <div id="result-detail" style="font-size:13px;color:#e5e7eb;margin-bottom:16px;"></div>
    <button id="btn-restart">같은 모드로 다시 하기</button>
    <button id="btn-to-start">처음 화면으로</button>
  </div>
</div>

<script>
/*  
  ===== Nine Men's Morris FULL SCRIPT =====
  AI + 규칙 + 이동 + 포석 + 밀 체크 + 결과창
*/
const MODE = { SINGLE:'single', MULTI:'multi' };
let mode = null;

const EMPTY = null;
const WHITE = 'W';
const BLACK = 'B';

let board = Array(24).fill(null);

let currentSide = WHITE;
let humanSide = null;
let aiSide = null;

let placedWhite = 0;
let placedBlack = 0;
const MAX_PIECES = 9;

let selectedIndex = null;
let gamePhase = 'placing';

const adj = {
  0:[1,9],       1:[0,2,4],        2:[1,14],
  3:[4,10],      4:[1,3,5,7],      5:[4,13],
  6:[7,11],      7:[4,6,8],        8:[7,12],
  9:[0,10,21],   10:[3,9,11,18],   11:[6,10,15],
  12:[8,13,17],  13:[5,12,14,20],  14:[2,13,23],
  15:[11,16],    16:[15,17,19],    17:[12,16],
  18:[10,19],    19:[16,18,20,22], 20:[13,19],
  21:[9,22],     22:[19,21,23],    23:[14,22]
};

const mills = [
  [0,1,2],[3,4,5],[6,7,8],
  [15,16,17],[18,19,20],[21,22,23],
  [0,9,21],[3,10,18],[6,11,15],
  [8,12,17],[5,13,20],[2,14,23],
  [1,4,7],[16,19,22]
];

function hasMill(index, side) {
  for (const m of mills) {
    if (m.includes(index) && m.every(i => board[i] === side)) return true;
  }
  return false;
}

function enemyPieces(side) {
  const e = side === WHITE ? BLACK : WHITE;
  return board.map((v,i)=>({v,i})).filter(o=>o.v===e).map(o=>o.i);
}

function removePieceAt(i) {
  board[i] = EMPTY;
  updateBoardUI();
}

function placePiece(i, side) {
  board[i] = side;
  if (side === WHITE) placedWhite++;
  else placedBlack++;
}

function canMoveAnywhere(i, side) {
  if (remainingPieces(side) === 3) return true;
  return adj[i].some(n => board[n] === EMPTY);
}

function remainingPieces(side) {
  return board.filter(v => v===side).length;
}

function nextSide(s) {
  return s===WHITE ? BLACK : WHITE;
}

function updateInfoBar() {
  const modeText = document.querySelector('#mode-text');
  const turnText = document.querySelector('#turn-text');
  const roleText = document.querySelector('#role-text');

  if (mode === MODE.SINGLE) {
    const who = humanSide === WHITE ? '플레이어(흰)' : '플레이어(검)';
    modeText.textContent = `혼자 게임하기: ${who}`;
  } else {
    modeText.textContent = `둘이 게임하기`;
  }

  turnText.textContent = currentSide === WHITE ? '흰 말 차례' : '검은 말 차례';

  if (gamePhase === 'placing')
    roleText.textContent = `포석 단계: 번갈아 9개씩 말 놓기`;
  else
    roleText.textContent = `이동 단계: 인접한 칸으로 이동`;
}

function updateBoardUI() {
  document.querySelectorAll('.cell').forEach(cell => {
    const idx = Number(cell.dataset.index);
    const v = board[idx];
    cell.classList.remove('empty','W','B','selected');
    if (v === EMPTY) cell.classList.add('empty');
    else cell.classList.add(v);
  });
}

function checkGameOver() {
  const whiteCount = remainingPieces(WHITE);
  const blackCount = remainingPieces(BLACK);

  if (whiteCount <= 2) return BLACK;
  if (blackCount <= 2) return WHITE;

  if (gamePhase === 'moving') {
    let wMove = board
      .map((v,i)=>(v===WHITE && canMoveAnywhere(i,WHITE)))
      .some(v=>v);
    let bMove = board
      .map((v,i)=>(v===BLACK && canMoveAnywhere(i,BLACK)))
      .some(v=>v);
    if (!wMove) return BLACK;
    if (!bMove) return WHITE;
  }

  return null;
}

function showResult(winner) {
  const ov=document.getElementById('result-overlay');
  const msg=document.getElementById('result-message');
  const detail=document.getElementById('result-detail');
  msg.textContent = winner===WHITE ? '흰 말 승!' : '검은 말 승!';
  detail.textContent = '상대방이 2개 이하이거나 이동 불가 상태가 되었습니다.';
  ov.classList.remove('hidden');
}

function startSingle() {
  mode = MODE.SINGLE;
  resetGame();

  humanSide = Math.random() < 0.5 ? WHITE : BLACK;
  aiSide = nextSide(humanSide);

  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.remove('hidden');

  updateInfoBar();

  if (currentSide === aiSide)
    setTimeout(aiTurn, 1000);
}

function startMulti() {
  mode = MODE.MULTI;
  resetGame();

  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.remove('hidden');

  updateInfoBar();
}

function resetGame() {
  board = Array(24).fill(EMPTY);
  currentSide = WHITE;
  placedWhite = 0;
  placedBlack = 0;
  gamePhase = 'placing';
  selectedIndex = null;
  updateBoardUI();
  updateInfoBar();
}

function handleCellClick(e) {
  const idx = Number(e.target.dataset.index);
  const v = board[idx];

  if (gamePhase === 'placing') {
    if (v !== EMPTY) return;

    if (mode===MODE.SINGLE && currentSide!==humanSide) return;

    placePiece(idx, currentSide);
    updateBoardUI();

    if (hasMill(idx, currentSide)) {
      let list = enemyPieces(currentSide===WHITE?BLACK:WHITE);
      removePieceAt(list[0]);
    }

    if (placedWhite===9 && placedBlack===9) gamePhase='moving';

    let w = checkGameOver();
    if (w) return showResult(w);

    currentSide = nextSide(currentSide);
    updateInfoBar();

    if (mode===MODE.SINGLE && currentSide===aiSide)
      setTimeout(aiTurn,1000);

    return;
  }

  if (gamePhase === 'moving') {
    if (mode===MODE.SINGLE && currentSide!==humanSide) return;

    if (selectedIndex === null) {
      if (v !== currentSide) return;
      selectedIndex = idx;
      document.querySelector(`.cell[data-index="${idx}"]`).classList.add('selected');
      return;
    }

    const from = selectedIndex;
    const to = idx;

    if (board[to]===EMPTY && adj[from].includes(to)) {
      board[from]=EMPTY;
      board[to]=currentSide;
      selectedIndex=null;
      updateBoardUI();

      if (hasMill(to, currentSide)) {
        let list = enemyPieces(currentSide===WHITE?BLACK:WHITE);
        removePieceAt(list[0]);
      }

      let w = checkGameOver();
      if (w) return showResult(w);

      currentSide = nextSide(currentSide);
      updateInfoBar();

      if (mode===MODE.SINGLE && currentSide===aiSide)
        setTimeout(aiTurn,1000);

    } else {
      document.querySelector(`.cell[data-index="${from}"]`).classList.remove('selected');
      selectedIndex=null;
    }
  }
}

function aiTurn() {
  let empty = board.map((v,i)=>(v===EMPTY?i:null)).filter(v=>v!==null);

  if (gamePhase==='placing') {
    let i = empty[Math.floor(Math.random()*empty.length)];
    placePiece(i,aiSide);
    updateBoardUI();

    if (hasMill(i,aiSide)) {
      let list = enemyPieces(humanSide);
      removePieceAt(list[0]);
    }

    if (placedWhite===9 && placedBlack===9) gamePhase='moving';

    let w = checkGameOver();
    if (w) return showResult(w);

    currentSide = humanSide;
    updateInfoBar();
    return;
  }

  if (gamePhase==='moving') {
    let movables = board
      .map((v,i)=>({v,i}))
      .filter(o=>o.v===aiSide && canMoveAnywhere(o.i,aiSide));

    let from = movables[Math.floor(Math.random()*movables.length)].i;
    let targets = adj[from].filter(n=>board[n]===EMPTY);
    let to = targets[Math.floor(Math.random()*targets.length)];

    board[from]=EMPTY;
    board[to]=aiSide;
    updateBoardUI();

    if (hasMill(to,aiSide)) {
      let list = enemyPieces(humanSide);
      removePieceAt(list[0]);
    }

    let w = checkGameOver();
    if (w) return showResult(w);

    currentSide = humanSide;
    updateInfoBar();
  }
}

document.querySelectorAll('.cell').forEach(c=>{
  c.addEventListener('click',handleCellClick);
});

document.getElementById('btn-single').onclick=startSingle;
document.getElementById('btn-multi').onclick=startMulti;

document.getElementById('btn-back').onclick=()=>{
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};

document.getElementById('btn-restart').onclick=()=>{
  document.getElementById('result-overlay').classList.add('hidden');
  if (mode===MODE.SINGLE) startSingle();
  else startMulti();
};
document.getElementById('btn-to-start').onclick=()=>{
  document.getElementById('result-overlay').classList.add('hidden');
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};
</script>

</body>
</html>
