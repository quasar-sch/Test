<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Nine Men's Morris</title>
<style>
:root{
  --board-bg:#d1d5db;
  --board-edge:#4b5563;
  --line:#4b5563;
  --white-piece:#fef3c7;
  --white-border:#b45309;
  --black-piece:#020617;
  --black-border:#e5e7eb;
}
*{box-sizing:border-box;}

body{
  margin:0;
  padding:40px 16px;
  background:#f3f4f6;
  font-family:ui-sans-serif,system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",Segoe UI,Roboto,Helvetica,Arial;
  text-align:center;
}

button{
  padding:10px 16px;
  margin:6px;
  font-size:15px;
  cursor:pointer;
  border-radius:8px;
  border:1px solid #4b5563;
  background:#fff;
  transition:0.15s;
}
button:hover{
  transform:translateY(-1px);
  background:#f9fafb;
  box-shadow:0 4px 10px rgba(0,0,0,0.12);
}
.hidden{display:none;}

#game-screen,#start-screen{
  max-width:640px;
  margin:0 auto;
}

#board-wrapper{display:flex;justify-content:center;}

#board{
  width:400px;
  max-width:90vw;
  aspect-ratio:1/1;
  position:relative;
  border-radius:24px;
  background:radial-gradient(circle at 20% -10%,#e5e7eb,var(--board-bg));
  border:3px solid var(--board-edge);
  box-shadow:0 12px 40px rgba(0,0,0,0.22);
  overflow:hidden;
}

/* SVG 라인 */
#edges{
  position:absolute;
  inset:0;
  z-index:0;
}
#edges line{
  stroke:var(--line);
  stroke-width:2.5;
  stroke-linecap:round;
}

/* 말(점) */
.cell{
  width:24px;height:24px;border-radius:50%;
  position:absolute;transform:translate(-50%,-50%);
  cursor:pointer;z-index:1;
}
.cell.empty{background:#e5e7eb;border:2px solid var(--board-edge);}
.cell.W{
  background:var(--white-piece);border:3px solid var(--white-border);
  box-shadow:0 0 0 2px rgba(255,255,255,0.7);
}
.cell.B{
  background:var(--black-piece);border:3px solid var(--black-border);
  box-shadow:0 0 0 2px rgba(0,0,0,0.5);
}
.cell.selected{box-shadow:0 0 0 4px rgba(59,130,246,0.9);}

#result-overlay{
  position:fixed;inset:0;
  background:rgba(15,23,42,0.55);
  display:flex;align-items:center;justify-content:center;
  z-index:1000;
}
#result-overlay.hidden{display:none;}
#result-box{
  background:#111827;color:#f9fafb;
  padding:20px;border-radius:16px;
  border:1px solid #4b5563;
  min-width:260px;
}
</style>
</head>

<body>

<!-- 시작 화면 -->
<div id="start-screen">
  <h1>Nine Men's Morris</h1>
  <p>혼자 게임하기: 플레이어 vs 컴퓨터 (선/후공 랜덤)</p>
  <p>둘이 게임하기: 같은 컴퓨터에서 번갈아 두기</p>
  <button id="btn-single">혼자 게임하기</button>
  <button id="btn-multi">둘이 게임하기</button>
</div>

<!-- 게임 화면 -->
<div id="game-screen" class="hidden">
  <div id="mode-text"></div>
  <div id="turn-text"></div>
  <div id="role-text" style="font-size:13px;color:#4b5563;margin-bottom:8px;"></div>

  <div id="board-wrapper">
    <div id="board">
      <!-- 이동 경로(선)는 JS에서 adjacency 기반으로 SVG로 자동 생성 -->
      <svg id="edges" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>

      <!-- 24개 점 위치 -->
      <!-- 바깥 8 -->
      <div class="cell empty" data-index="0"  style="left:10%; top:10%;"></div>
      <div class="cell empty" data-index="1"  style="left:50%; top:10%;"></div>
      <div class="cell empty" data-index="2"  style="left:90%; top:10%;"></div>
      <div class="cell empty" data-index="9"  style="left:10%; top:50%;"></div>
      <div class="cell empty" data-index="14" style="left:90%; top:50%;"></div>
      <div class="cell empty" data-index="21" style="left:10%; top:90%;"></div>
      <div class="cell empty" data-index="22" style="left:50%; top:90%;"></div>
      <div class="cell empty" data-index="23" style="left:90%; top:90%;"></div>

      <!-- 중간 8 -->
      <div class="cell empty" data-index="3"  style="left:20%; top:20%;"></div>
      <div class="cell empty" data-index="4"  style="left:50%; top:20%;"></div>
      <div class="cell empty" data-index="5"  style="left:80%; top:20%;"></div>
      <div class="cell empty" data-index="10" style="left:20%; top:50%;"></div>
      <div class="cell empty" data-index="13" style="left:80%; top:50%;"></div>
      <div class="cell empty" data-index="18" style="left:20%; top:80%;"></div>
      <div class="cell empty" data-index="19" style="left:50%; top:80%;"></div>
      <div class="cell empty" data-index="20" style="left:80%; top:80%;"></div>

      <!-- 안쪽 8 -->
      <div class="cell empty" data-index="6"  style="left:30%; top:30%;"></div>
      <div class="cell empty" data-index="7"  style="left:50%; top:30%;"></div>
      <div class="cell empty" data-index="8"  style="left:70%; top:30%;"></div>
      <div class="cell empty" data-index="11" style="left:30%; top:50%;"></div>
      <div class="cell empty" data-index="12" style="left:70%; top:50%;"></div>
      <div class="cell empty" data-index="15" style="left:30%; top:70%;"></div>
      <div class="cell empty" data-index="16" style="left:50%; top:70%;"></div>
      <div class="cell empty" data-index="17" style="left:70%; top:70%;"></div>
    </div>
  </div>

  <div id="hint-text" style="margin-top:8px;font-size:13px;color:#4b5563;"></div>

  <button id="btn-back" style="margin-top:10px;">처음으로</button>
</div>

<!-- 결과화면 -->
<div id="result-overlay" class="hidden">
  <div id="result-box">
    <div id="result-message" style="font-size:22px;margin-bottom:8px;"></div>
    <div id="result-detail" style="font-size:13px;color:#e5e7eb;margin-bottom:16px;"></div>
    <button id="btn-restart">같은 모드로 다시 하기</button>
    <button id="btn-to-start">처음 화면으로</button>
  </div>
</div>

<script>
// ===== 기본 상수 & 상태 =====
const MODE = { SINGLE:'single', MULTI:'multi' };
const EMPTY = null, WHITE='W', BLACK='B';
const MAX_PIECES = 9;
const AI_DELAY = 500; // 인공지능 딜레이 (0.5초)

let mode = null;
let board = Array(24).fill(EMPTY);
let currentSide = WHITE;
let humanSide = null;
let aiSide = null;
let placed = { W:0, B:0 };   // 포석으로 올린 말 개수
let count  = { W:0, B:0 };   // 현재 판 위의 말 개수
let selectedIndex = null;
let gameOver = false;

// 말 좌표 (퍼센트 단위, 위의 style과 동일)
const coord = {
  0:{x:10,y:10}, 1:{x:50,y:10}, 2:{x:90,y:10},
  3:{x:20,y:20}, 4:{x:50,y:20}, 5:{x:80,y:20},
  6:{x:30,y:30}, 7:{x:50,y:30}, 8:{x:70,y:30},
  9:{x:10,y:50},10:{x:20,y:50},11:{x:30,y:50},12:{x:70,y:50},13:{x:80,y:50},14:{x:90,y:50},
 15:{x:30,y:70},16:{x:50,y:70},17:{x:70,y:70},
 18:{x:20,y:80},19:{x:50,y:80},20:{x:80,y:80},
 21:{x:10,y:90},22:{x:50,y:90},23:{x:90,y:90}
};

// 인접 리스트 (여기 적힌 쌍만 선으로 그리고, 이동도 이 경로만 가능)
const adj = {
  0:[1,9],
  1:[0,2,4],
  2:[1,14],
  3:[4,10],
  4:[1,3,5,7],
  5:[4,13],
  6:[7,11],
  7:[4,6,8],
  8:[7,12],
  9:[0,10,21],
 10:[3,9,11,18],
 11:[6,10,15],
 12:[8,13,17],
 13:[5,12,14,20],
 14:[2,13,23],
 15:[11,16],
 16:[15,17,19],
 17:[12,16],
 18:[10,19],
 19:[16,18,20,22],
 20:[13,19],
 21:[9,22],
 22:[19,21,23],
 23:[14,22]
};

// 밀(3개 일직선) 패턴들
const mills = [
  [0,1,2],[3,4,5],[6,7,8],
  [15,16,17],[18,19,20],[21,22,23],
  [0,9,21],[3,10,18],[6,11,15],
  [8,12,17],[5,13,20],[2,14,23],
  [1,4,7],[16,19,22]
];

const otherSide = s => s===WHITE?BLACK:WHITE;
const cellEl = i => document.querySelector(`.cell[data-index="${i}"]`);
const isPlacingPhase = () => placed.W < MAX_PIECES || placed.B < MAX_PIECES;

// ===== 보드 라인 그리기 (adjacency → SVG 선) =====
(function drawEdges(){
  const svg = document.getElementById('edges');
  const drawn = new Set();
  for(const [aStr, ns] of Object.entries(adj)){
    const a = Number(aStr);
    for(const b of ns){
      const key = a<b ? `${a}-${b}` : `${b}-${a}`;
      if(drawn.has(key)) continue;
      drawn.add(key);
      const p1 = coord[a], p2 = coord[b];
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', p1.x);
      line.setAttribute('y1', p1.y);
      line.setAttribute('x2', p2.x);
      line.setAttribute('y2', p2.y);
      svg.appendChild(line);
    }
  }
})();

// ===== 보조 함수들 =====
function hasMill(idx, side){
  return mills.some(m => m.includes(idx) && m.every(i => board[i]===side));
}
function hasAnyMove(side){
  if(count[side]<=2) return false;
  for(let i=0;i<24;i++){
    if(board[i]!==side) continue;
    for(const n of adj[i]){
      if(board[n]===EMPTY) return true;
    }
  }
  return false;
}
function updateBoardUI(){
  document.querySelectorAll('.cell').forEach(cell=>{
    const idx = Number(cell.dataset.index);
    const v = board[idx];
    cell.classList.remove('empty','W','B','selected');
    if(v===EMPTY) cell.classList.add('empty');
    else cell.classList.add(v);
  });
}
function updateInfoBar(){
  const modeText = document.getElementById('mode-text');
  const turnText = document.getElementById('turn-text');
  const roleText = document.getElementById('role-text');
  const hintText = document.getElementById('hint-text');

  if(mode===MODE.SINGLE){
    const who = humanSide===WHITE ? '플레이어: 흰 말' : '플레이어: 검은 말';
    modeText.textContent = `혼자 게임하기 (${who})`;
  }else if(mode===MODE.MULTI){
    modeText.textContent = '둘이 게임하기';
  }else{
    modeText.textContent = '';
  }

  let turn = currentSide===WHITE?'흰 말 차례':'검은 말 차례';
  if(mode===MODE.SINGLE){
    turn += currentSide===humanSide?' (플레이어)':' (컴퓨터)';
  }
  turnText.textContent = turn;

  if(isPlacingPhase()){
    roleText.textContent = '포석 단계: 번갈아 자신의 말을 빈 점에 놓습니다. (각 9개)';
  }else{
    roleText.textContent = '이동 단계: 자신의 말을 인접한 빈 점으로 한 칸씩 이동합니다.';
  }

  hintText.textContent = '';
}
function resetGame(){
  board = Array(24).fill(EMPTY);
  currentSide = WHITE;
  placed = {W:0,B:0};
  count  = {W:0,B:0};
  selectedIndex = null;
  gameOver=false;
  updateBoardUI();
  updateInfoBar();
}
function endGame(winner){
  gameOver=true;
  const ov=document.getElementById('result-overlay');
  const msg=document.getElementById('result-message');
  const detail=document.getElementById('result-detail');
  msg.textContent = winner===WHITE?'흰 말 승리!':'검은 말 승리!';
  detail.textContent = '상대 말이 2개 이하이거나 더 이상 움직일 수 없습니다.';
  ov.classList.remove('hidden');
}
function checkGameOverAfterMove(side){
  // 포석 단계에서는 절대 게임 끝나지 않게
  if(isPlacingPhase()) return;
  const opp = otherSide(side);
  if(count[opp]<=2){ endGame(side); return; }
  if(!hasAnyMove(opp)){ endGame(side); return; }
}

// ===== 턴 공통 처리 (밀이면 자동으로 상대 말 하나 제거) =====
function afterPlacedOrMoved(lastIdx){
  const side=currentSide;
  const opp=otherSide(side);

  if(hasMill(lastIdx, side) && count[opp]>0){
    // 간단 버전: 상대 말 아무거나 하나 자동 제거
    const candidates=[];
    for(let i=0;i<24;i++) if(board[i]===opp) candidates.push(i);
    if(candidates.length){
      const t = candidates[Math.floor(Math.random()*candidates.length)];
      board[t]=EMPTY;
      count[opp]--;
    }
  }

  updateBoardUI();
  checkGameOverAfterMove(side);
  if(gameOver) return;

  currentSide = opp;
  updateInfoBar();

  if(mode===MODE.SINGLE && currentSide===aiSide){
    setTimeout(aiTurn, AI_DELAY);
  }
}

// ===== 사람 클릭 처리 =====
function handleCellClick(e){
  if(gameOver) return;
  const idx = Number(e.target.dataset.index);
  if(Number.isNaN(idx)) return;

  if(mode===MODE.SINGLE && currentSide===aiSide) return; // AI 차례엔 입력 막기

  if(isPlacingPhase()){
    if(board[idx]!==EMPTY) return;
    // 포석
    board[idx]=currentSide;
    placed[currentSide]++;
    count[currentSide]++;
    afterPlacedOrMoved(idx);
    return;
  }

  // 이동 단계
  if(selectedIndex===null){
    if(board[idx]!==currentSide) return;
    selectedIndex=idx;
    cellEl(idx).classList.add('selected');
    return;
  }else{
    if(idx===selectedIndex){
      cellEl(idx).classList.remove('selected');
      selectedIndex=null;
      return;
    }
    if(board[idx]!==EMPTY){
      // 자기 말 다른 거 선택
      if(board[idx]===currentSide){
        cellEl(selectedIndex).classList.remove('selected');
        selectedIndex=idx;
        cellEl(idx).classList.add('selected');
      }
      return;
    }
    const from=selectedIndex, to=idx;
    if(!adj[from].includes(to)) return;

    // 실제 이동
    board[from]=EMPTY;
    board[to]=currentSide;
    cellEl(from).classList.remove('selected');
    selectedIndex=null;
    afterPlacedOrMoved(to);
  }
}

// ===== AI =====
function aiTurn(){
  if(gameOver) return;
  if(currentSide!==aiSide) return;

  if(isPlacingPhase()){
    // 간단한 전략: 밀 만들 수 있으면 거기로, 아니면 랜덤
    const empties=[];
    for(let i=0;i<24;i++) if(board[i]===EMPTY) empties.push(i);
    let choice=null;
    for(const i of empties){
      board[i]=aiSide;
      const ok = hasMill(i,aiSide);
      board[i]=EMPTY;
      if(ok){ choice=i; break; }
    }
    if(choice===null){
      choice = empties[Math.floor(Math.random()*empties.length)];
    }
    board[choice]=aiSide;
    placed[aiSide]++; count[aiSide]++;
    afterPlacedOrMoved(choice);
    return;
  }

  // 이동 단계: 가능한 이동 중 밀 만드는 수가 있으면 우선, 아니면 랜덤
  const moves=[];
  for(let from=0;from<24;from++){
    if(board[from]!==aiSide) continue;
    for(const to of adj[from]){
      if(board[to]===EMPTY) moves.push({from,to});
    }
  }
  if(!moves.length){ checkGameOverAfterMove(aiSide); return; }

  let best=null;
  for(const m of moves){
    board[m.from]=EMPTY; board[m.to]=aiSide;
    const ok=hasMill(m.to,aiSide);
    board[m.to]=EMPTY; board[m.from]=aiSide;
    if(ok){ best=m; break; }
  }
  const chosen = best || moves[Math.floor(Math.random()*moves.length)];
  board[chosen.from]=EMPTY;
  board[chosen.to]=aiSide;
  afterPlacedOrMoved(chosen.to);
}

// ===== 화면 전환 및 버튼 =====
document.querySelectorAll('.cell').forEach(c=>{
  c.addEventListener('click',handleCellClick);
});

document.getElementById('btn-single').onclick=()=>{
  mode=MODE.SINGLE;
  resetGame();
  humanSide = Math.random()<0.5 ? WHITE : BLACK;
  aiSide = otherSide(humanSide);
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.remove('hidden');
  updateInfoBar();
  if(currentSide===aiSide) setTimeout(aiTurn,AI_DELAY);
};

document.getElementById('btn-multi').onclick=()=>{
  mode=MODE.MULTI;
  resetGame();
  humanSide=null; aiSide=null;
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.remove('hidden');
  updateInfoBar();
};

document.getElementById('btn-back').onclick=()=>{
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};

document.getElementById('btn-restart').onclick=()=>{
  document.getElementById('result-overlay').classList.add('hidden');
  if(mode===MODE.SINGLE){
    document.getElementById('game-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
  }else{
    resetGame();
    document.getElementById('result-overlay').classList.add('hidden');
  }
};

document.getElementById('btn-to-start').onclick=()=>{
  document.getElementById('result-overlay').classList.add('hidden');
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('start-screen').classList.remove('hidden');
};
</script>

</body>
</html>
