<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>Nine Men's Morris</title>
<style>
:root{
  --board-bg:#d1d5db;
  --board-edge:#4b5563;
  --line:#4b5563;
  --white-piece:#fef3c7;
  --white-border:#b45309;
  --black-piece:#020617;
  --black-border:#e5e7eb;
}

*{box-sizing:border-box;}

body{
  margin:0;
  padding:40px 16px;
  background:#f3f4f6;
  font-family:ui-sans-serif,system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",Segoe UI,Roboto,Helvetica,Arial;
  text-align:center;
}

h1{margin-top:0;}

button{
  padding:10px 16px;
  margin:6px;
  font-size:15px;
  cursor:pointer;
  border-radius:8px;
  border:1px solid #4b5563;
  background:#fff;
  transition:0.15s;
}
button:hover{
  transform:translateY(-1px);
  background:#f9fafb;
  box-shadow:0 4px 10px rgba(0,0,0,0.12);
}

.hidden{display:none;}

#game-screen,#start-screen{
  max-width:640px;
  margin:0 auto;
}

#info-bar{
  margin-bottom:8px;
  font-size:15px;
}
#info-bar>div{margin:2px 0;}

#mode-text{
  font-size:14px;
  color:#4b5563;
}

#turn-text{
  display:flex;
  justify-content:center;
  align-items:center;
  margin-top:4px;
}

.turn-pill{
  padding:4px 12px;
  border-radius:999px;
  font-size:13px;
  font-weight:600;
  display:inline-flex;
  align-items:center;
  gap:6px;
}
.turn-dot{
  width:10px;height:10px;border-radius:50%;
  border:1px solid rgba(0,0,0,0.25);
}
.turn-pill.white{
  background:#fefce8;
  color:#92400e;
  border:1px solid #fbbf24;
}
.turn-pill.white .turn-dot{
  background:#fef3c7;
}
.turn-pill.black{
  background:#020617;
  color:#e5e7eb;
  border:1px solid #9ca3af;
}
.turn-pill.black .turn-dot{
  background:#020617;
  border-color:#e5e7eb;
}

#role-text{
  font-size:13px;
  color:#4b5563;
  margin-bottom:8px;
  min-height:18px;
}

#board-wrapper{display:flex;justify-content:center;}

#board{
  width:400px;
  max-width:90vw;
  aspect-ratio:1/1;
  position:relative;
  border-radius:24px;
  background:radial-gradient(circle at 20% -10%,#e5e7eb,var(--board-bg));
  border:3px solid var(--board-edge);
  box-shadow:0 12px 40px rgba(0,0,0,0.22);
  overflow:hidden;
  transition:box-shadow 0.2s ease, border-color 0.2s ease;
}
#board.turn-white{
  box-shadow:0 14px 42px rgba(59,130,246,0.35);
  border-color:#93c5fd;
}
#board.turn-black{
  box-shadow:0 14px 42px rgba(15,23,42,0.55);
  border-color:#4b5563;
}

/* 이동 가능 경로 라인 (adjacency 기반) */
#edges{
  position:absolute;
  inset:0;
  z-index:0;
}
#edges line{
  stroke:var(--line);
  stroke-width:1.6;   /* ★ 더 얇게 */
  stroke-linecap:round;
}

/* 24개 점(말) */
.cell{
  width:26px;
  height:26px;
  border-radius:50%;
  position:absolute;
  transform:translate(-50%,-50%);
  z-index:1;
  cursor:pointer;
  transition:transform 0.15s ease, box-shadow 0.15s ease;
}
.cell.empty{
  background:#e5e7eb;
  border:2px solid var(--board-edge);
}
.cell.W{
  background:var(--white-piece);
  border:3px solid var(--white-border);
  box-shadow:0 0 0 2px rgba(255,255,255,0.7);
}
.cell.B{
  background:var(--black-piece);
  border:3px solid var(--black-border);
  box-shadow:0 0 0 2px rgba(0,0,0,0.5);
}
.cell.selected{
  box-shadow:0 0 0 5px rgba(59,130,246,0.95);
  transform:translate(-50%,-50%) scale(1.1);
}

/* 놓거나 옮길 때 “톡” 튀는 모션 */
.cell.pulse{
  animation:pulsePiece 0.18s ease-out;
}
@keyframes pulsePiece{
  0%{transform:translate(-50%,-50%) scale(0.8);}
  60%{transform:translate(-50%,-50%) scale(1.15);}
  100%{transform:translate(-50%,-50%) scale(1);}
}

#hint-text{
  margin-top:8px;
  font-size:13px;
  color:#4b5563;
  min-height:18px;
}

/* 결과 오버레이 */
#result-overlay{
  position:fixed;
  inset:0;
  background:rgba(15,23,42,0.55);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:999;
}
#result-overlay.hidden{display:none;}
#result-box{
  background:#111827;
  color:#f9fafb;
  padding:20px;
  border-radius:14px;
  border:1px solid #4b5563;
  min-width:260px;
}
#result-message{
  font-size:22px;
  margin-bottom:10px;
}
#result-box p{
  margin:4px 0 14px;
  font-size:14px;
  color:#e5e7eb;
}
</style>
</head>

<body>
<!-- 시작 화면 -->
<div id="start-screen">
  <h1>Nine Men's Morris</h1>
  <p>혼자 게임하기: 플레이어 vs 컴퓨터 (선/후공 랜덤)</p>
  <p>둘이 게임하기: 같은 컴퓨터에서 번갈아 두기</p>
  <button id="btn-single">혼자 게임하기</button>
  <button id="btn-multi">둘이 게임하기</button>
</div>

<!-- 게임 화면 -->
<div id="game-screen" class="hidden">
  <div id="info-bar">
    <div id="mode-text"></div>
    <div id="turn-text"></div>
  </div>
  <div id="role-text"></div>

  <div id="board-wrapper">
    <div id="board">
      <!-- adjacency 기반 선 -->
      <svg id="edges" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>

      <!-- 바깥 8 -->
      <div class="cell empty" data-index="0"  style="left:10%; top:10%;"></div>
      <div class="cell empty" data-index="1"  style="left:50%; top:10%;"></div>
      <div class="cell empty" data-index="2"  style="left:90%; top:10%;"></div>
      <div class="cell empty" data-index="9"  style="left:10%; top:50%;"></div>
      <div class="cell empty" data-index="14" style="left:90%; top:50%;"></div>
      <div class="cell empty" data-index="21" style="left:10%; top:90%;"></div>
      <div class="cell empty" data-index="22" style="left:50%; top:90%;"></div>
      <div class="cell empty" data-index="23" style="left:90%; top:90%;"></div>

      <!-- 중간 8 -->
      <div class="cell empty" data-index="3"  style="left:20%; top:20%;"></div>
      <div class="cell empty" data-index="4"  style="left:50%; top:20%;"></div>
      <div class="cell empty" data-index="5"  style="left:80%; top:20%;"></div>
      <div class="cell empty" data-index="10" style="left:20%; top:50%;"></div>
      <div class="cell empty" data-index="13" style="left:80%; top:50%;"></div>
      <div class="cell empty" data-index="18" style="left:20%; top:80%;"></div>
      <div class="cell empty" data-index="19" style="left:50%; top:80%;"></div>
      <div class="cell empty" data-index="20" style="left:80%; top:80%;"></div>

      <!-- 안쪽 8 -->
      <div class="cell empty" data-index="6"  style="left:30%; top:30%;"></div>
      <div class="cell empty" data-index="7"  style="left:50%; top:30%;"></div>
      <div class="cell empty" data-index="8"  style="left:70%; top:30%;"></div>
      <div class="cell empty" data-index="11" style="left:30%; top:50%;"></div>
      <div class="cell empty" data-index="12" style="left:70%; top:50%;"></div>
      <div class="cell empty" data-index="15" style="left:30%; top:70%;"></div>
      <div class="cell empty" data-index="16" style="left:50%; top:70%;"></div>
      <div class="cell empty" data-index="17" style="left:70%; top:70%;"></div>
    </div>
  </div>

  <div id="hint-text"></div>
  <button id="btn-back" style="margin-top:10px;">처음으로</button>
</div>

<!-- 결과 화면 -->
<div id="result-overlay" class="hidden">
  <div id="result-box">
    <div id="result-message"></div>
    <p id="result-detail"></p>
    <button id="btn-restart">같은 모드로 다시 하기</button>
    <button id="btn-to-start">처음 화면으로</button>
  </div>
</div>

<script>
/* ===== 상수 & 상태 ===== */
const MODE = { SINGLE:'single', MULTI:'multi' };
const EMPTY = null, WHITE='W', BLACK='B';
const MAX_PIECES = 9;
const AI_DELAY = 650; // 0.5초 → 30% 느리게

let mode = null;
let board = Array(24).fill(EMPTY);
let currentSide = WHITE;
let piecesToPlace = { W:9, B:9 }; // 포석으로 올릴 말 수
let pieceCount   = { W:0, B:0 };  // 현재 판 위 말 수

let humanSide = null;
let aiSide = null;
let gameOver = false;
let mustRemoveSide = null;   // 밀을 만들어서 제거해야 하는 쪽
let selectedIndex = null;

/* DOM */
const startScreen   = document.getElementById('start-screen');
const gameScreen    = document.getElementById('game-screen');
const resultOverlay = document.getElementById('result-overlay');
const resultMessage = document.getElementById('result-message');
const resultDetail  = document.getElementById('result-detail');
const modeText      = document.getElementById('mode-text');
const turnText      = document.getElementById('turn-text');
const roleText      = document.getElementById('role-text');
const hintText      = document.getElementById('hint-text');
const boardEl       = document.getElementById('board');
const edgesSvg      = document.getElementById('edges');

/* 좌표 (퍼센트) */
const coord = {
  0:{x:10,y:10}, 1:{x:50,y:10}, 2:{x:90,y:10},
  3:{x:20,y:20}, 4:{x:50,y:20}, 5:{x:80,y:20},
  6:{x:30,y:30}, 7:{x:50,y:30}, 8:{x:70,y:30},
  9:{x:10,y:50},10:{x:20,y:50},11:{x:30,y:50},12:{x:70,y:50},13:{x:80,y:50},14:{x:90,y:50},
 15:{x:30,y:70},16:{x:50,y:70},17:{x:70,y:70},
 18:{x:20,y:80},19:{x:50,y:80},20:{x:80,y:80},
 21:{x:10,y:90},22:{x:50,y:90},23:{x:90,y:90}
};

/* 인접 리스트 (이동 가능 경로 = 여기만 선 그림) */
const neighbors = {
  0:[1,9],
  1:[0,2,4],
  2:[1,14],
  3:[4,10],
  4:[1,3,5,7],
  5:[4,13],
  6:[7,11],
  7:[4,6,8],
  8:[7,12],
  9:[0,10,21],
 10:[3,9,11,18],
 11:[6,10,15],
 12:[8,13,17],
 13:[5,12,14,20],
 14:[2,13,23],
 15:[11,16],
 16:[15,17,19],
 17:[12,16],
 18:[10,19],
 19:[16,18,20,22],
 20:[13,19],
 21:[9,22],
 22:[19,21,23],
 23:[14,22]
};

/* 밀(3개 일직선, 대각선 없음) */
const mills = [
  [0,1,2],[3,4,5],[6,7,8],[9,10,11],
  [12,13,14],[15,16,17],[18,19,20],[21,22,23],
  [0,9,21],[3,10,18],[6,11,15],
  [1,4,7],[16,19,22],
  [8,12,17],[5,13,20],[2,14,23]
];

const otherSide = s => s===WHITE?BLACK:WHITE;
const isMovingPhase = () => piecesToPlace.W===0 && piecesToPlace.B===0;
const cellEl = i => boardEl.querySelector('.cell[data-index="'+i+'"]');

/* ===== 라인 그리기 (adjacency → SVG) ===== */
(function drawEdges(){
  const drawn = new Set();
  for(const [aStr, list] of Object.entries(neighbors)){
    const a = Number(aStr);
    for(const b of list){
      const key = a<b ? `${a}-${b}` : `${b}-${a}`;
      if(drawn.has(key)) continue;
      drawn.add(key);
      const p1 = coord[a], p2 = coord[b];
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',p1.x);
      line.setAttribute('y1',p1.y);
      line.setAttribute('x2',p2.x);
      line.setAttribute('y2',p2.y);
      edgesSvg.appendChild(line);
    }
  }
})();

/* ===== 유틸 ===== */
function clearSelection(){
  if(selectedIndex!==null){
    const el = cellEl(selectedIndex);
    if(el) el.classList.remove('selected');
  }
  selectedIndex=null;
}
function resetBoardVisual(){
  boardEl.querySelectorAll('.cell').forEach(c=>{
    c.className='cell empty';
  });
}
function pulseCell(i){
  const el = cellEl(i);
  if(!el) return;
  el.classList.add('pulse');
  setTimeout(()=>el.classList.remove('pulse'),180);
}
function placePiece(i,side){
  board[i]=side;
  pieceCount[side]++;
  const el=cellEl(i);
  if(el){
    el.classList.remove('empty','W','B','selected');
    el.classList.add(side);
    pulseCell(i);
  }
}
function movePiece(from,to,side){
  board[from]=EMPTY;
  board[to]=side;
  const a=cellEl(from), b=cellEl(to);
  if(a) a.className='cell empty';
  if(b){
    b.classList.remove('empty','W','B','selected');
    b.classList.add(side);
    pulseCell(to);
  }
}
function removePiece(i,side){
  if(board[i]!==side) return;
  board[i]=EMPTY;
  pieceCount[side]--;
  const el=cellEl(i);
  if(el) el.className='cell empty';
}
function isMillAt(i,side){
  return mills.some(m=>m.includes(i) && m.every(j=>board[j]===side));
}
function existsRemovableOpponentPiece(forSide){
  const opp=otherSide(forSide);
  return pieceCount[opp]>0;
}
function canRemoveThis(i,removerSide){
  const opp=otherSide(removerSide);
  return board[i]===opp;
}
function hasAnyLegalMove(side){
  // 이동 단계에서만 호출됨
  if(pieceCount[side]<=2) return false;
  for(let i=0;i<24;i++){
    if(board[i]!==side) continue;
    for(const n of neighbors[i]){
      if(board[n]===EMPTY) return true;
    }
  }
  return false;
}
function checkGameOver(afterSide){
  if(!isMovingPhase()) return false; // 포석 단계에서는 승부 안 남
  const opp=otherSide(afterSide);
  if(pieceCount[opp]<=2){
    endGame(afterSide,'pieces'); return true;
  }
  if(!hasAnyLegalMove(opp)){
    endGame(afterSide,'noMoves'); return true;
  }
  return false;
}

/* ===== UI ===== */
function updateInfoBar(){
  // 보드 테두리/그림자 색으로 현재 차례 강조
  boardEl.classList.remove('turn-white','turn-black');
  boardEl.classList.add(currentSide===WHITE ? 'turn-white' : 'turn-black');

  if(mode===MODE.SINGLE){
    const who = humanSide===WHITE ? '플레이어 = 흰 말(선공)' : '플레이어 = 검은 말(후공)';
    modeText.textContent = `모드: 혼자 게임하기 · ${who}`;
    roleText.textContent = humanSide===WHITE ? '플레이어 말: 흰 말 / 컴퓨터: 검은 말' : '플레이어 말: 검은 말 / 컴퓨터: 흰 말';
  }else if(mode===MODE.MULTI){
    modeText.textContent='모드: 둘이 게임하기 · P1: 흰 말 · P2: 검은 말';
    roleText.textContent='번갈아 한 수씩 두세요.';
  }else{
    modeText.textContent='';
    roleText.textContent='';
  }

  let label = currentSide===WHITE ? '흰 말 차례' : '검은 말 차례';
  let sideClass = currentSide===WHITE ? 'white' : 'black';
  let tail = '';

  if(mode===MODE.SINGLE){
    tail = currentSide===humanSide ? '플레이어' : '컴퓨터';
  }else if(mode===MODE.MULTI){
    tail = currentSide===WHITE ? '플레이어 1' : '플레이어 2';
  }

  turnText.innerHTML =
    `<span class="turn-pill ${sideClass}">
       <span class="turn-dot"></span>
       ${label}${tail ? ' · '+tail : ''}
     </span>`;

  if(mustRemoveSide && mustRemoveSide===currentSide){
    hintText.textContent='밀 완성! 상대 말을 하나 클릭해서 제거하세요.';
    return;
  }

  if(!isMovingPhase()){
    hintText.textContent='포석 단계: 번갈아 자신의 말을 빈 점에 놓습니다. (각 9개)';
  }else{
    hintText.textContent='이동 단계: 자신의 말을 인접한 빈 점으로 한 칸 이동합니다. (대각선·점프 없음)';
  }
}

function endGame(winner,reason){
  gameOver=true;
  let msg, detail;
  if(mode===MODE.SINGLE){
    msg = winner===humanSide ? '플레이어 승!' : '컴퓨터 승!';
  }else{
    msg = winner===WHITE ? '흰 말 승!' : '검은 말 승!';
  }
  if(reason==='noMoves') detail='상대가 더 이상 움직일 수 없어서 승리했습니다.';
  else if(reason==='pieces') detail='상대 말이 2개 이하로 남아서 승리했습니다.';
  else detail='게임 종료';

  resultMessage.textContent=msg;
  resultDetail.textContent=detail;
  resultOverlay.classList.remove('hidden');
}

function initGameState(){
  board = Array(24).fill(EMPTY);
  piecesToPlace = {W:9,B:9};
  pieceCount = {W:0,B:0};
  currentSide = WHITE;
  gameOver=false;
  mustRemoveSide=null;
  clearSelection();
  resetBoardVisual();
}

function goToGameScreen(){
  startScreen.classList.add('hidden');
  gameScreen.classList.remove('hidden');
}
function goToStartScreen(){
  gameScreen.classList.add('hidden');
  startScreen.classList.remove('hidden');
  resultOverlay.classList.add('hidden');
}

function startSingleGame(){
  mode=MODE.SINGLE;
  initGameState();
  humanSide = Math.random()<0.5 ? WHITE : BLACK;
  aiSide    = otherSide(humanSide);
  goToGameScreen();
  updateInfoBar();
  if(currentSide===aiSide) setTimeout(aiTurn,AI_DELAY);
}
function startMultiGame(){
  mode=MODE.MULTI;
  humanSide=null; aiSide=null;
  initGameState();
  goToGameScreen();
  updateInfoBar();
}
function restartCurrentMode(){
  resultOverlay.classList.add('hidden');
  if(mode===MODE.SINGLE) startSingleGame();
  else if(mode===MODE.MULTI) startMultiGame();
}

/* ===== 턴 종료 공통 처리 (포석/이동 모두) ===== */
function onMoveFinished(lastIdx){
  const side=currentSide;
  const opp = otherSide(side);

  // 밀 완성 → 제거 모드
  if(isMillAt(lastIdx,side) && existsRemovableOpponentPiece(side)){
    mustRemoveSide = side;
    updateInfoBar();
    if(mode===MODE.SINGLE && side===aiSide){
      setTimeout(aiTurn,AI_DELAY);
    }
    return;
  }

  // 밀이 아니면 → 승부 체크 후 턴 넘김
  if(checkGameOver(side)) return;
  currentSide = opp;
  updateInfoBar();
  if(mode===MODE.SINGLE && currentSide===aiSide){
    setTimeout(aiTurn,AI_DELAY);
  }
}

/* ===== 사람 클릭 처리 ===== */
function handleBoardClick(idx){
  if(gameOver) return;

  // 제거 단계
  if(mustRemoveSide){
    // 싱글에서 AI 차례라면 사람 입력 무시
    if(mode===MODE.SINGLE && mustRemoveSide===aiSide) return;
    if(mustRemoveSide!==currentSide) return;
    if(!canRemoveThis(idx,currentSide)) return;

    const opp = otherSide(currentSide);
    removePiece(idx,opp);
    mustRemoveSide=null;
    if(checkGameOver(currentSide)) return;
    currentSide = opp;
    updateInfoBar();
    if(mode===MODE.SINGLE && currentSide===aiSide){
      setTimeout(aiTurn,AI_DELAY);
    }
    return;
  }

  // AI 차례엔 입력 막기
  if(mode===MODE.SINGLE && currentSide===aiSide) return;

  // 포석 단계
  if(!isMovingPhase()){
    if(board[idx]!==EMPTY) return;
    placePiece(idx,currentSide);
    piecesToPlace[currentSide]--;
    onMoveFinished(idx);
    return;
  }

  // 이동 단계
  const side=currentSide;
  if(selectedIndex===null){
    if(board[idx]!==side) return;
    selectedIndex=idx;
    cellEl(idx)?.classList.add('selected');
  }else{
    if(idx===selectedIndex){
      clearSelection();
      return;
    }
    if(board[idx]!==EMPTY){
      if(board[idx]===side){
        cellEl(selectedIndex)?.classList.remove('selected');
        selectedIndex=idx;
        cellEl(idx)?.classList.add('selected');
      }
      return;
    }
    const from=selectedIndex, to=idx;
    if(!neighbors[from].includes(to)) return; // 점프 금지
    movePiece(from,to,side);
    clearSelection();
    onMoveFinished(to);
  }
}

/* ===== AI ===== */
function aiTurn(){
  if(gameOver) return;
  if(currentSide!==aiSide) return;

  // 1) 제거 모드일 때
  if(mustRemoveSide===aiSide){
    const target = pickAiRemoveTarget(aiSide);
    if(target!==null){
      const opp=otherSide(aiSide);
      removePiece(target,opp);
      mustRemoveSide=null;
      if(checkGameOver(aiSide)) return;
      currentSide = opp;
      updateInfoBar();
    }
    return;
  }

  // 2) 포석 단계
  if(!isMovingPhase()){
    const idx = pickAiPlaceIndex(aiSide);
    if(idx===null) return;
    placePiece(idx,aiSide);
    piecesToPlace[aiSide]--;
    onMoveFinished(idx);
    return;
  }

  // 3) 이동 단계
  const move = pickAiMove(aiSide);
  if(!move){
    if(!hasAnyLegalMove(aiSide)){
      endGame(otherSide(aiSide),'noMoves');
    }
    return;
  }
  movePiece(move.from,move.to,aiSide);
  onMoveFinished(move.to);
}

function pickAiPlaceIndex(side){
  const opp=otherSide(side);
  // 1) 나 밀 만드는 자리
  for(let i=0;i<24;i++){
    if(board[i]!==EMPTY) continue;
    board[i]=side;
    const ok=isMillAt(i,side);
    board[i]=EMPTY;
    if(ok) return i;
  }
  // 2) 상대 밀 막는 자리
  for(let i=0;i<24;i++){
    if(board[i]!==EMPTY) continue;
    board[i]=opp;
    const ok=isMillAt(i,opp);
    board[i]=EMPTY;
    if(ok) return i;
  }
  // 3) 랜덤
  const empties=[];
  for(let i=0;i<24;i++) if(board[i]===EMPTY) empties.push(i);
  if(!empties.length) return null;
  return empties[Math.floor(Math.random()*empties.length)];
}

function pickAiRemoveTarget(side){
  const opp=otherSide(side);
  const cand=[];
  for(let i=0;i<24;i++) if(board[i]===opp) cand.push(i);
  if(!cand.length) return null;
  return cand[Math.floor(Math.random()*cand.length)];
}

function pickAiMove(side){
  const opp=otherSide(side);
  const moves=[];
  for(let from=0;from<24;from++){
    if(board[from]!==side) continue;
    for(const to of neighbors[from]){
      if(board[to]===EMPTY) moves.push({from,to});
    }
  }
  if(!moves.length) return null;

  // 1) 나 밀 만드는 이동
  for(const m of moves){
    board[m.from]=EMPTY; board[m.to]=side;
    const ok=isMillAt(m.to,side);
    board[m.to]=EMPTY; board[m.from]=side;
    if(ok) return m;
  }
  // 2) 상대 밀 막는 이동
  for(const m of moves){
    board[m.from]=EMPTY; board[m.to]=opp;
    const ok=isMillAt(m.to,opp);
    board[m.to]=EMPTY; board[m.from]=side;
    if(ok) return m;
  }
  // 3) 랜덤
  return moves[Math.floor(Math.random()*moves.length)];
}

/* 이벤트 바인딩 */
document.getElementById('btn-single').addEventListener('click',startSingleGame);
document.getElementById('btn-multi').addEventListener('click',startMultiGame);
document.getElementById('btn-back').addEventListener('click',goToStartScreen);
document.getElementById('btn-restart').addEventListener('click',restartCurrentMode);
document.getElementById('btn-to-start').addEventListener('click',()=>{
  resultOverlay.classList.add('hidden');
  goToStartScreen();
});
boardEl.addEventListener('click',e=>{
  const cell=e.target.closest('.cell');
  if(!cell) return;
  const idx=Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  handleBoardClick(idx);
});
</script>
</body>
</html>
